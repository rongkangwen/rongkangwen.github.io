(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{573:function(t,s,v){"use strict";v.r(s);var a=v(22),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"函数进阶"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#函数进阶"}},[t._v("#")]),t._v(" 函数进阶")]),t._v(" "),v("h2",{attrs:{id:"闭包"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),v("p",[v("strong",[t._v("闭包")]),t._v(" 是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时\n就产生了闭包。(你不知道的JavaScript书中的书法)")])]),t._v(" "),v("li",[v("p",[t._v("一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）（MDN对闭包的解释）")])])])]),t._v(" "),v("p",[t._v("在javascript中，所有函数都是天生闭包（"),v("code",[t._v("new Function")]),t._v("创建的函数除外）")]),t._v(" "),v("p",[t._v("JavaScript 中的函数会自动通过隐藏的 "),v("code",[t._v("[[Environment]]")]),t._v(" 属性记住创建它们的位置，所以它们都可以访问外部变量")]),t._v(" "),v("h2",{attrs:{id:"箭头函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[t._v("#")]),t._v(" 箭头函数")]),t._v(" "),v("div",{staticClass:"custom-block note"},[v("p",{staticClass:"custom-block-title"},[t._v("笔记")]),t._v(" "),v("ul",[v("li",[t._v("没有"),v("code",[t._v("this")])]),t._v(" "),v("li",[t._v("没有"),v("code",[t._v("arguments")])]),t._v(" "),v("li",[t._v("不能使用"),v("code",[t._v("new")]),t._v("进行操作")]),t._v(" "),v("li",[t._v("它们也没有 "),v("code",[t._v("super")])])])])])}),[],!1,null,null,null);s.default=e.exports}}]);